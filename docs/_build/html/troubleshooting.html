<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Troubleshooting Guide - NOUS Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
            background: #fafafa;
        }
        
        .content {
            background: white;
            padding: 3rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2563eb;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 0.5rem;
            margin-top: 0;
        }
        
        h2 {
            color: #1e40af;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.3rem;
            margin-top: 2rem;
        }
        
        h3 {
            color: #1f2937;
            margin-top: 1.5rem;
        }
        
        code {
            background: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.875rem;
        }
        
        pre {
            background: #f8f9fa;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        p {
            margin: 1rem 0;
        }
        
        strong {
            color: #374151;
            font-weight: 600;
        }
        
        em {
            color: #6b7280;
            font-style: italic;
        }
        
        .navigation {
            background: #2563eb;
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }
        
        .navigation a {
            color: white;
            text-decoration: none;
            margin-right: 1rem;
        }
        
        .navigation a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="navigation">
        <a href="index.html">Home</a>
        <a href="overview.html">Overview</a>
        <a href="installation.html">Installation</a>
        <a href="api_reference.html">API Reference</a>
        <a href="architecture.html">Architecture</a>
        <a href="development.html">Development</a>
        <a href="deployment.html">Deployment</a>
        <a href="troubleshooting.html">Troubleshooting</a>
        <a href="changelog.html">Changelog</a>
    </div>
    
    <div class="content">
        <h1>Troubleshooting Guide</h1>
<br>
<p>This guide provides solutions to common issues encountered when deploying, configuring, and using NOUS Personal Assistant.</p>
<br>
<h2>Common Issues and Solutions</h2>
<br>
<h3>Authentication Problems</h3>
<br>
<strong>Issue: "OAuth redirect URI mismatch"<strong>
<br>
<p>This error occurs when the redirect URI configured in Google Console doesn't match the application's callback URL.</p>
<br>
<em>Solution:<em>
<br>
<p>1. Check your Google Cloud Console OAuth configuration</p>
<p>2. Ensure redirect URIs match exactly:</p>
<br>
<pre><code>
   
   Development: http://localhost:5000/oauth/callback
   Production: https://your-app.replit.app/oauth/callback

</code></pre>
<p>3. Verify BASE_URL environment variable:</p>
<br>
<pre><code>
   
   # Check current setting
   echo $BASE_URL
   
   # Should match your domain
   BASE_URL=https://your-app.replit.app

</code></pre>
<strong>Issue: "Authentication loop - keeps redirecting to login"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Check session configuration:</p>
<br>
<pre><code>
   
   # Verify session secret is set
   import os
   print(os.getenv('SESSION_SECRET'))

</code></pre>
<p>2. Clear browser cookies and cache</p>
<br>
<p>3. Verify ProxyFix middleware configuration:</p>
<br>
<pre><code>
   
   from werkzeug.middleware.proxy_fix import ProxyFix
   app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

</code></pre>
<strong>Issue: "Google OAuth client not found"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Verify client secrets are properly configured:</p>
<br>
<pre><code>
   
   # Check if client_secret.json exists
   ls -la client_secret.json
   
   # Or check environment variables
   echo $GOOGLE_CLIENT_ID
   echo $GOOGLE_CLIENT_SECRET

</code></pre>
<p>2. Regenerate OAuth credentials if necessary</p>
<br>
<h3>Database Issues</h3>
<br>
<strong>Issue: "Database connection failed"<strong>
<br>
<em>Symptoms:<em> Application crashes on startup, "SQLAlchemy connection error"
<br>
<em>Solution:<em>
<br>
<p>1. Check DATABASE_URL format:</p>
<br>
<pre><code>
   
   # Correct format
   DATABASE_URL=postgresql://user:password@host:port/database
   
   # For Replit (automatic)
   DATABASE_URL=${REPLIT_DB_URL}

</code></pre>
<p>2. Test database connection:</p>
<br>
<pre><code>
   
   from sqlalchemy import create_engine
   import os
   
   try:
       engine = create_engine(os.getenv('DATABASE_URL'))
       with engine.connect() as conn:
           result = conn.execute('SELECT 1').scalar()
           print(f"Database connection successful: {result}")
   except Exception as e:
       print(f"Database connection failed: {e}")

</code></pre>
<p>3. For Replit, ensure PostgreSQL is enabled in the project</p>
<br>
<strong>Issue: "Table doesn't exist" errors<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Initialize database tables:</p>
<br>
<pre><code>
   
   python -c "from app import app, db; app.app_context().push(); db.create_all()"

</code></pre>
<p>2. Check model imports in app.py:</p>
<br>
<pre><code>
   
   # Ensure all models are imported
   import models  # This should import all model files

</code></pre>
<strong>Issue: "Connection pool exhausted"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Optimize connection pool settings:</p>
<br>
<pre><code>
   
   app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
       "pool_size": 2,           # Reduce for resource-constrained environments
       "max_overflow": 5,        # Lower overflow limit
       "pool_recycle": 1800,     # Recycle connections more frequently
       "pool_pre_ping": True     # Validate connections
   }

</code></pre>
<p>2. Close database connections properly:</p>
<br>
<pre><code>
   
   try:
       result = db.session.query(User).all()
   finally:
       db.session.close()

</code></pre>
<h3>AI Service Issues</h3>
<br>
<strong>Issue: "OpenRouter API key invalid"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Verify API key is correct:</p>
<br>
<pre><code>
   
   # Test API key
   curl -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        https://openrouter.ai/api/v1/models

</code></pre>
<p>2. Check if key has expired or needs renewal</p>
<br>
<p>3. Test with fallback provider (HuggingFace)</p>
<br>
<strong>Issue: "AI response timeout"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Increase timeout settings:</p>
<br>
<pre><code>
   
   import requests
   
   response = requests.post(
       url,
       json=data,
       timeout=60  # Increase from default 30s
   )

</code></pre>
<p>2. Implement retry logic:</p>
<br>
<pre><code>
   
   import time
   from functools import wraps
   
   def retry_on_failure(retries=3, delay=1):
       def decorator(func):
           @wraps(func)
           def wrapper(*args, **kwargs):
               for attempt in range(retries):
                   try:
                       return func(*args, **kwargs)
                   except Exception as e:
                       if attempt == retries - 1:
                           raise e
                       time.sleep(delay * (2 ** attempt))
           return wrapper
       return decorator

</code></pre>
<strong>Issue: "HuggingFace inference API rate limited"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Implement request queuing:</p>
<br>
<pre><code>
   
   import asyncio
   from asyncio import Semaphore
   
   # Limit concurrent requests
   semaphore = Semaphore(2)
   
   async def limited_api_call(data):
       async with semaphore:
           return await make_api_call(data)

</code></pre>
<p>2. Add authentication token for higher limits:</p>
<br>
<pre><code>
   
   HUGGINGFACE_API_KEY=your_token_here

</code></pre>
<h3>Deployment Issues</h3>
<br>
<strong>Issue: "Application won't start on Replit"<strong>
<br>
<em>Symptoms:<em> Replit shows "Application not responding"
<br>
<em>Solution:<em>
<br>
<p>1. Check run configuration in replit.toml:</p>
<br>
<pre><code>
   
   run = ["python3", "main.py"]

</code></pre>
<p>2. Verify main.py launches the app:</p>
<br>
<pre><code>
   
   from app import app
   
   if __name__ == "__main__":
       app.run(host="0.0.0.0", port=5000)

</code></pre>
<p>3. Check application logs in Replit console</p>
<br>
<strong>Issue: "Port already in use"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Use environment-specified port:</p>
<br>
<pre><code>
   
   import os
   port = int(os.environ.get('PORT', 5000))
   app.run(host='0.0.0.0', port=port)

</code></pre>
<p>2. Kill existing processes:</p>
<br>
<pre><code>
   
   # Find process using port
   lsof -i :5000
   
   # Kill process
   kill -9 <PID>

</code></pre>
<strong>Issue: "Static files not loading"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Verify static file configuration:</p>
<br>
<pre><code>
   
   app = Flask(__name__, static_folder='static', static_url_path='/static')

</code></pre>
<p>2. Check file permissions:</p>
<br>
<pre><code>
   
   ls -la static/
   chmod 644 static/*.css static/*.js

</code></pre>
<p>3. Clear browser cache</p>
<br>
<h3>Performance Issues</h3>
<br>
<strong>Issue: "Slow database queries"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Add database indexes:</p>
<br>
<pre><code>
   
   # In model definitions
   class User(db.Model):
       email = db.Column(db.String(255), index=True)
       created_at = db.Column(db.DateTime, index=True)

</code></pre>
<p>2. Optimize queries with eager loading:</p>
<br>
<pre><code>
   
   # Instead of N+1 queries
   users = User.query.options(
       db.joinedload(User.feedback)
   ).all()

</code></pre>
<p>3. Use query profiling:</p>
<br>
<pre><code>
   
   import time
   
   start_time = time.time()
   result = db.session.query(User).all()
   duration = time.time() - start_time
   
   if duration > 0.1:
       print(f"Slow query detected: {duration:.3f}s")

</code></pre>
<strong>Issue: "High memory usage"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Monitor memory usage:</p>
<br>
<pre><code>
   
   import psutil
   
   process = psutil.Process()
   memory_mb = process.memory_info().rss / 1024 / 1024
   print(f"Memory usage: {memory_mb:.1f} MB")

</code></pre>
<p>2. Implement pagination:</p>
<br>
<pre><code>
   
   def get_users_paginated(page=1, per_page=20):
       return User.query.paginate(
           page=page,
           per_page=per_page,
           error_out=False
       )

</code></pre>
<p>3. Use connection pooling and close sessions:</p>
<br>
<pre><code>
   
   try:
       # Database operations
       pass
   finally:
       db.session.close()

</code></pre>
<h3>SSL/TLS Issues</h3>
<br>
<strong>Issue: "Mixed content warnings"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Ensure all resources use HTTPS:</p>
<br>
<pre><code>
   
   <!-- Good -->
   <script src="https://cdn.example.com/script.js"></script>
   
   <!-- Bad in HTTPS context -->
   <script src="http://cdn.example.com/script.js"></script>

</code></pre>
<p>2. Use protocol-relative URLs:</p>
<br>
<pre><code>
   
   <script src="//cdn.example.com/script.js"></script>

</code></pre>
<strong>Issue: "SSL certificate errors"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. For Replit: SSL is automatic, check domain configuration</p>
<br>
<p>2. For custom domains, verify certificate installation:</p>
<br>
<pre><code>
   
   # Check certificate
   openssl s_client -connect your-domain.com:443 -servername your-domain.com

</code></pre>
<h3>Frontend Issues</h3>
<br>
<strong>Issue: "JavaScript errors in console"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Check for CSRF token issues:</p>
<br>
<pre><code>
   
   // Ensure CSRF token is included
   const csrfToken = document.querySelector('meta[name=csrf-token]')?.getAttribute('content');
   
   fetch('/api/endpoint', {
       method: 'POST',
       headers: {
           'Content-Type': 'application/json',
           'X-CSRFToken': csrfToken
       },
       body: JSON.stringify(data)
   });

</code></pre>
<p>2. Fix CORS issues:</p>
<br>
<pre><code>
   
   @app.after_request
   def after_request(response):
       response.headers.add('Access-Control-Allow-Origin', '*')
       response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
       response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE')
       return response

</code></pre>
<strong>Issue: "Chat interface not responding"<strong>
<br>
<em>Solution:<em>
<br>
<p>1. Check API endpoint connectivity:</p>
<br>
<pre><code>
   
   // Test API endpoint
   fetch('/api/v1/health')
       .then(response => response.json())
       .then(data => console.log('API Status:', data))
       .catch(error => console.error('API Error:', error));

</code></pre>
<p>2. Verify WebSocket connections (if used):</p>
<br>
<pre><code>
   
   const ws = new WebSocket('wss://your-domain.com/ws');
   ws.onopen = () => console.log('WebSocket connected');
   ws.onerror = (error) => console.error('WebSocket error:', error);

</code></pre>
<h2>Debugging Tools and Techniques</h2>
<br>
<h3>Logging Configuration</h3>
<br>
<p>Enable comprehensive logging:</p>
<br>
<pre><code>

import logging

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

# Log database queries
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

</code></pre>
<h3>Health Check Diagnostics</h3>
<br>
<p>Use built-in health endpoints:</p>
<br>
<pre><code>

# Basic health check
curl https://your-app.replit.app/health

# Comprehensive health check
curl https://your-app.replit.app/healthz

# Chat system health
curl https://your-app.replit.app/api/v1/health/chat

</code></pre>
<h3>Database Diagnostics</h3>
<br>
<pre><code>

# Check database connectivity
def diagnose_database():
    try:
        # Test basic connection
        result = db.session.execute('SELECT 1').scalar()
        print(f"✅ Database connection: OK ({result})")
        
        # Check table existence
        tables = db.inspect(db.engine).get_table_names()
        print(f"✅ Tables found: {len(tables)}")
        
        # Check user count
        user_count = User.query.count()
        print(f"✅ Users in database: {user_count}")
        
    except Exception as e:
        print(f"❌ Database error: {e}")

</code></pre>
<h3>API Diagnostics</h3>
<br>
<pre><code>

# Test external API connections
def diagnose_apis():
    apis = {
        'OpenRouter': 'https://openrouter.ai/api/v1/models',
        'HuggingFace': 'https://huggingface.co/api/models'
    }
    
    for name, url in apis.items():
        try:
            response = requests.get(url, timeout=10)
            print(f"✅ {name}: {response.status_code}")
        except Exception as e:
            print(f"❌ {name}: {e}")

</code></pre>
<h2>Performance Monitoring</h2>
<br>
<h3>Real-time Monitoring</h3>
<br>
<pre><code>

import psutil
import time

def monitor_performance():
    """Monitor system performance metrics."""
    while True:
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # Memory usage
        memory = psutil.virtual_memory()
        memory_percent = memory.percent
        
        # Database connections
        db_pool = db.engine.pool
        pool_size = db_pool.size()
        checked_out = db_pool.checkedout()
        
        print(f"CPU: {cpu_percent}% | Memory: {memory_percent}% | DB Pool: {checked_out}/{pool_size}")
        
        time.sleep(5)

</code></pre>
<h3>Query Performance Analysis</h3>
<br>
<pre><code>

from sqlalchemy import event
from sqlalchemy.engine import Engine
import time

# Log slow queries
@event.listens_for(Engine, "before_cursor_execute")
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    context._query_start_time = time.time()

@event.listens_for(Engine, "after_cursor_execute")
def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    total = time.time() - context._query_start_time
    if total > 0.1:  # Log queries slower than 100ms
        logger.warning(f"Slow query: {total:.3f}s - {statement[:100]}...")

</code></pre>
<h2>Error Recovery Procedures</h2>
<br>
<h3>Application Recovery</h3>
<br>
<p>If the application becomes unresponsive:</p>
<br>
<p>1. <strong>Restart Application<strong></p>
<br>
<pre><code>
   
   # On Replit: Click stop/start
   # On other platforms: restart service
   sudo systemctl restart your-app

</code></pre>
<p>2. <strong>Clear Sessions<strong></p>
<br>
<pre><code>
   
   # Clear session files
   import os
   import glob
   
   session_files = glob.glob('flask_session/*')
   for file in session_files:
       os.remove(file)

</code></pre>
<p>3. <strong>Reset Database Connections<strong></p>
<br>
<pre><code>
   
   # Reset connection pool
   db.engine.dispose()

</code></pre>
<h3>Database Recovery</h3>
<br>
<p>For database issues:</p>
<br>
<p>1. <strong>Connection Pool Reset<strong></p>
<br>
<pre><code>
   
   from app import db
   db.engine.dispose()

</code></pre>
<p>2. <strong>Table Recreation<strong> (Development only)</p>
<br>
<pre><code>
   
   from app import app, db
   with app.app_context():
       db.drop_all()
       db.create_all()

</code></pre>
<p>3. <strong>Backup Restoration<strong></p>
<br>
<pre><code>
   
   # Restore from backup
   psql $DATABASE_URL < backup.sql

</code></pre>
<h2>Emergency Contacts and Resources</h2>
<br>
<h3>Support Channels</h3>
<br>
<em> <strong>Replit Support<strong>: For platform-specific issues
<em> <strong>Google Cloud Support<strong>: For OAuth and API issues
<em> <strong>PostgreSQL Community<strong>: For database-related problems
<br>
<h3>Documentation Resources</h3>
<br>
<em> <strong>Flask Documentation<strong>: https://flask.palletsprojects.com/
<em> <strong>SQLAlchemy Documentation<strong>: https://docs.sqlalchemy.org/
<em> <strong>Replit Documentation<strong>: https://docs.replit.com/
<br>
<h3>Logs and Monitoring</h3>
<br>
<p>Key log files to check:</p>
<br>
<em> Application logs: <code>logs/app.log<code>
<em> Error logs: <code>logs/error.log<code>
<em> Access logs: <code>logs/access.log<code>
<em> Database logs: Check PostgreSQL logs
<br>
<p>Health check URLs:</p>
<br>
<em> <code>/health<code> - Basic status
<em> <code>/healthz<code> - Comprehensive health
<em> <code>/api/v1/health/chat<code> - Chat system status
<br>
<p>This troubleshooting guide covers the most common issues encountered with NOUS Personal Assistant. For issues not covered here, check the application logs and health endpoints for additional diagnostic information.</p>
    </div>
</body>
</html>