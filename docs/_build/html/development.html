<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Development Guide - NOUS Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
            background: #fafafa;
        }
        
        .content {
            background: white;
            padding: 3rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2563eb;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 0.5rem;
            margin-top: 0;
        }
        
        h2 {
            color: #1e40af;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.3rem;
            margin-top: 2rem;
        }
        
        h3 {
            color: #1f2937;
            margin-top: 1.5rem;
        }
        
        code {
            background: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.875rem;
        }
        
        pre {
            background: #f8f9fa;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        p {
            margin: 1rem 0;
        }
        
        strong {
            color: #374151;
            font-weight: 600;
        }
        
        em {
            color: #6b7280;
            font-style: italic;
        }
        
        .navigation {
            background: #2563eb;
            color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }
        
        .navigation a {
            color: white;
            text-decoration: none;
            margin-right: 1rem;
        }
        
        .navigation a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="navigation">
        <a href="index.html">Home</a>
        <a href="overview.html">Overview</a>
        <a href="installation.html">Installation</a>
        <a href="api_reference.html">API Reference</a>
        <a href="architecture.html">Architecture</a>
        <a href="development.html">Development</a>
        <a href="deployment.html">Deployment</a>
        <a href="troubleshooting.html">Troubleshooting</a>
        <a href="changelog.html">Changelog</a>
    </div>
    
    <div class="content">
        <h1>Development Guide</h1>
<br>
<p>This guide provides comprehensive information for developers working on NOUS Personal Assistant, including development workflows, coding standards, testing practices, and contribution guidelines.</p>
<br>
<h2>Development Environment Setup</h2>
<br>
<h3>Prerequisites</h3>
<br>
<em> <strong>Python 3.11+<strong>: Core runtime environment
<em> <strong>PostgreSQL 13+<strong>: Production database (SQLite for development)
<em> <strong>Git<strong>: Version control
<em> <strong>Code Editor<strong>: VS Code, PyCharm, or similar with Python support
<br>
<h3>Quick Setup</h3>
<br>
<pre><code>

# Clone repository
git clone https://github.com/your-username/nous-personal-assistant.git
cd nous-personal-assistant

# Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt
pip install -r requirements_dev.txt

# Set up environment
cp .env.example .env
# Edit .env with your configuration

# Initialize database
python -c "from app import app, db; app.app_context().push(); db.create_all()"

# Run application
python main.py

</code></pre>
<h2>Development Workflow</h2>
<br>
<h3>Git Workflow</h3>
<br>
<p>We follow a simplified Git flow:</p>
<br>
<pre><code>

# Create feature branch
git checkout -b feature/your-feature-name

# Make changes
git add .
git commit -m "feat: add new feature description"

# Push branch
git push origin feature/your-feature-name

# Create pull request via GitHub

</code></pre>
<h3>Commit Message Convention</h3>
<br>
<p>We use conventional commit format:</p>
<br>
<pre><code>

type(scope): description

[optional body]

[optional footer]

</code></pre>
<strong>Types:<strong>
<br>
<em> <code>feat<code>: New feature
<em> <code>fix<code>: Bug fix
<em> <code>docs<code>: Documentation changes
<em> <code>style<code>: Code formatting changes
<em> <code>refactor<code>: Code refactoring
<em> <code>test<code>: Adding or updating tests
<em> <code>chore<code>: Maintenance tasks
<br>
<strong>Examples:<strong>
<br>
<pre><code>

feat(auth): add Google OAuth integration
fix(api): resolve chat endpoint error handling
docs(api): update API reference documentation
refactor(utils): optimize database connection pooling

</code></pre>
<h2>Code Quality Standards</h2>
<br>
<h3>Code Style</h3>
<br>
<p>We follow PEP 8 with some modifications:</p>
<br>
<pre><code>

# Maximum line length: 88 characters (Black default)
# Use double quotes for strings
# Use trailing commas in multi-line structures

# Good example
def process_chat_message(
    message: str,
    context: Dict[str, Any],
    user_id: Optional[int] = None,
) -> Dict[str, Any]:
    """Process a chat message and return response."""
    return {
        "response": "Generated response",
        "context": updated_context,
        "metadata": {"model": "gemini-pro"},
    }

</code></pre>
<h3>Type Hints</h3>
<br>
<p>Use type hints for all functions and class methods:</p>
<br>
<pre><code>

from typing import Dict, List, Optional, Union, Any

def get_user_by_id(user_id: int) -> Optional[User]:
    """Retrieve user by ID."""
    return User.query.get(user_id)

def process_api_response(
    response: Dict[str, Any]
) -> Union[str, Dict[str, Any]]:
    """Process external API response."""
    if response.get("error"):
        return {"error": response["error"]}
    return response.get("data", "")

</code></pre>
<h3>Documentation Standards</h3>
<br>
<p>Use Google-style docstrings:</p>
<br>
<pre><code>

def calculate_health_score(
    database_latency: float,
    memory_usage: float,
    cpu_usage: float
) -> Dict[str, Any]:
    """Calculate system health score based on metrics.
    
    Args:
        database_latency: Database response time in milliseconds
        memory_usage: Memory usage percentage (0-100)
        cpu_usage: CPU usage percentage (0-100)
        
    Returns:
        Dict containing health score and component ratings:
            {
                "overall_score": 85,
                "database": "healthy",
                "memory": "warning",
                "cpu": "healthy"
            }
            
    Raises:
        ValueError: If any metric is outside valid range
        
    Example:
        >>> calculate_health_score(25.5, 45.0, 12.3)
        {"overall_score": 92, "database": "healthy", ...}
    """
    if not (0 <= memory_usage <= 100):
        raise ValueError("Memory usage must be between 0 and 100")
    
    # Implementation here...

</code></pre>
<h3>Error Handling</h3>
<br>
<p>Implement comprehensive error handling:</p>
<br>
<pre><code>

import logging
from typing import Optional

logger = logging.getLogger(__name__)

def safe_api_call(url: str, timeout: int = 30) -> Optional[Dict]:
    """Make API call with comprehensive error handling."""
    try:
        response = requests.get(url, timeout=timeout)
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.Timeout:
        logger.error(f"API call timeout: {url}")
        return None
        
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP error for {url}: {e.response.status_code}")
        return None
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Request failed for {url}: {str(e)}")
        return None
        
    except ValueError as e:
        logger.error(f"Invalid JSON response from {url}: {str(e)}")
        return None

</code></pre>
<h2>Testing Guidelines</h2>
<br>
<h3>Test Structure</h3>
<br>
<p>Organize tests to mirror the application structure:</p>
<br>
<pre><code>

tests/
├── __init__.py
├── conftest.py              # Pytest configuration and fixtures
├── test_app.py              # Main application tests
├── test_models.py           # Database model tests
├── test_routes.py           # Route handler tests
├── test_api.py              # API endpoint tests
├── test_utils.py            # Utility function tests
└── integration/             # Integration tests
    ├── test_auth_flow.py    # Authentication flow tests
    └── test_chat_system.py  # Chat system tests

</code></pre>
<h3>Test Writing Guidelines</h3>
<br>
<pre><code>

import pytest
from app import app, db
from models.user import User

@pytest.fixture
def client():
    """Create test client."""
    app.config['TESTING'] = True
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    
    with app.test_client() as client:
        with app.app_context():
            db.create_all()
            yield client
            db.drop_all()

@pytest.fixture
def sample_user():
    """Create sample user for testing."""
    user = User(
        email='test@example.com',
        name='Test User',
        google_id='123456789'
    )
    db.session.add(user)
    db.session.commit()
    return user

def test_user_creation(client, sample_user):
    """Test user creation and retrieval."""
    assert sample_user.email == 'test@example.com'
    assert sample_user.name == 'Test User'
    assert User.query.count() == 1

def test_api_health_endpoint(client):
    """Test health check API endpoint."""
    response = client.get('/api/health')
    assert response.status_code == 200
    
    data = response.get_json()
    assert data['status'] == 'healthy'
    assert 'timestamp' in data

</code></pre>
<h3>Running Tests</h3>
<br>
<pre><code>

# Run all tests
pytest

# Run with coverage
pytest --cov=. --cov-report=html

# Run specific test file
pytest tests/test_api.py

# Run tests with specific marker
pytest -m "not slow"

# Verbose output
pytest -v

</code></pre>
<h2>Database Development</h2>
<br>
<h3>Model Development</h3>
<br>
<p>Create models following SQLAlchemy best practices:</p>
<br>
<pre><code>

from datetime import datetime
from app import db
from sqlalchemy.dialects.postgresql import UUID
import uuid

class BaseModel(db.Model):
    """Base model with common fields."""
    __abstract__ = True
    
    id = db.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(
        db.DateTime, 
        default=datetime.utcnow, 
        onupdate=datetime.utcnow, 
        nullable=False
    )

class User(BaseModel):
    """User model with OAuth integration."""
    __tablename__ = 'users'
    
    email = db.Column(db.String(255), unique=True, nullable=False, index=True)
    name = db.Column(db.String(255))
    google_id = db.Column(db.String(255), unique=True, index=True)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    last_login = db.Column(db.DateTime)
    
    # Relationships
    feedback = db.relationship('UserFeedback', backref='user', lazy='dynamic')
    
    def __repr__(self):
        return f'<User {self.email}>'
    
    def to_dict(self):
        """Convert user to dictionary for JSON serialization."""
        return {
            'id': str(self.id),
            'email': self.email,
            'name': self.name,
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat(),
            'last_login': self.last_login.isoformat() if self.last_login else None
        }

</code></pre>
<h3>Migration Strategy</h3>
<br>
<p>While we use <code>db.create_all()<code> for simplicity, consider Flask-Migrate for production:</p>
<br>
<pre><code>

# Initialize migrations (one time)
flask db init

# Create migration
flask db migrate -m "Add user table"

# Apply migration
flask db upgrade

# Downgrade if needed
flask db downgrade

</code></pre>
<h3>Query Optimization</h3>
<br>
<p>Write efficient database queries:</p>
<br>
<pre><code>

# Good: Use eager loading to avoid N+1 queries
users_with_feedback = User.query.options(
    db.joinedload(User.feedback)
).filter(User.is_active == True).all()

# Good: Use pagination for large datasets
def get_users_paginated(page: int = 1, per_page: int = 20):
    return User.query.filter(User.is_active == True).paginate(
        page=page, 
        per_page=per_page, 
        error_out=False
    )

# Good: Use database-level filtering
recent_users = User.query.filter(
    User.created_at >= datetime.utcnow() - timedelta(days=30)
).count()

</code></pre>
<h2>API Development</h2>
<br>
<h3>Endpoint Design</h3>
<br>
<p>Follow RESTful conventions:</p>
<br>
<pre><code>

from flask import Blueprint, request, jsonify
from utils.auth import require_auth, get_current_user

api_bp = Blueprint('api', __name__, url_prefix='/api')

@api_bp.route('/user', methods=['GET'])
@require_auth
def get_current_user_info():
    """Get current authenticated user information."""
    try:
        user = get_current_user()
        return jsonify({
            'data': user.to_dict(),
            'status': 'success'
        })
    except Exception as e:
        return jsonify({
            'error': {
                'code': 'USER_FETCH_ERROR',
                'message': 'Failed to retrieve user information'
            },
            'status': 'error'
        }), 500

@api_bp.route('/feedback', methods=['POST'])
@require_auth
def submit_feedback():
    """Submit user feedback."""
    try:
        data = request.get_json()
        
        # Validate input
        if not data or not data.get('message'):
            return jsonify({
                'error': {
                    'code': 'INVALID_INPUT',
                    'message': 'Feedback message is required'
                },
                'status': 'error'
            }), 400
        
        # Create feedback record
        feedback = UserFeedback(
            user_id=get_current_user().id,
            feedback_type=data.get('type', 'general'),
            message=data['message'],
            rating=data.get('rating'),
            metadata=data.get('metadata', {})
        )
        
        db.session.add(feedback)
        db.session.commit()
        
        return jsonify({
            'data': {'id': str(feedback.id)},
            'status': 'success'
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Feedback submission error: {str(e)}")
        return jsonify({
            'error': {
                'code': 'FEEDBACK_SUBMISSION_ERROR',
                'message': 'Failed to submit feedback'
            },
            'status': 'error'
        }), 500

</code></pre>
<h3>Input Validation</h3>
<br>
<p>Validate all API inputs:</p>
<br>
<pre><code>

from marshmallow import Schema, fields, validate, ValidationError

class FeedbackSchema(Schema):
    """Schema for feedback validation."""
    type = fields.Str(
        validate=validate.OneOf(['bug_report', 'feature_request', 'general']),
        missing='general'
    )
    message = fields.Str(required=True, validate=validate.Length(min=1, max=1000))
    rating = fields.Int(validate=validate.Range(min=1, max=5))
    metadata = fields.Dict()

@api_bp.route('/feedback', methods=['POST'])
@require_auth
def submit_feedback():
    """Submit user feedback with validation."""
    schema = FeedbackSchema()
    
    try:
        data = schema.load(request.get_json() or {})
    except ValidationError as e:
        return jsonify({
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'Invalid input data',
                'details': e.messages
            },
            'status': 'error'
        }), 400
    
    # Process valid data...

</code></pre>
<h2>Frontend Development</h2>
<br>
<h3>JavaScript Standards</h3>
<br>
<p>Use modern JavaScript with consistent style:</p>
<br>
<pre><code>

// Good: Use const/let, arrow functions, async/await
const ChatInterface = {
    async sendMessage(message) {
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCSRFToken()
                },
                body: JSON.stringify({ message })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            this.displayResponse(data.response);
            
        } catch (error) {
            console.error('Chat error:', error);
            this.displayError('Failed to send message. Please try again.');
        }
    },
    
    displayResponse(response) {
        const chatContainer = document.getElementById('chat-messages');
        const messageElement = document.createElement('div');
        messageElement.className = 'message ai-message';
        messageElement.textContent = response;
        chatContainer.appendChild(messageElement);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    },
    
    getCSRFToken() {
        return document.querySelector('meta[name=csrf-token]')?.getAttribute('content');
    }
};

</code></pre>
<h3>CSS Architecture</h3>
<br>
<p>Use consistent CSS methodology:</p>
<br>
<pre><code>

/* Use BEM methodology for CSS classes */
.chat-interface {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

.chat-interface__header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    background: var(--header-bg);
}

.chat-interface__messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
}

.message {
    margin-bottom: 1rem;
    padding: 0.75rem;
    border-radius: 0.5rem;
    max-width: 80%;
}

.message--user {
    background: var(--user-message-bg);
    margin-left: auto;
    text-align: right;
}

.message--ai {
    background: var(--ai-message-bg);
    margin-right: auto;
}

/* Responsive design */
@media (max-width: 768px) {
    .message {
        max-width: 95%;
    }
    
    .chat-interface__header {
        padding: 0.5rem;
    }
}

</code></pre>
<h2>Performance Optimization</h2>
<br>
<h3>Database Performance</h3>
<br>
<pre><code>

# Use database indexes
class User(db.Model):
    email = db.Column(db.String(255), unique=True, nullable=False, index=True)
    google_id = db.Column(db.String(255), unique=True, index=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)

# Use query optimization
def get_active_users_with_recent_activity():
    """Optimized query for active users."""
    return db.session.query(User).filter(
        User.is_active == True,
        User.last_login >= datetime.utcnow() - timedelta(days=30)
    ).options(
        db.load_only(User.id, User.email, User.name, User.last_login)
    ).limit(100).all()

</code></pre>
<h3>Caching Strategy</h3>
<br>
<pre><code>

from functools import lru_cache
import time

# Simple in-memory caching
@lru_cache(maxsize=128)
def get_feature_flag_cached(flag_name: str) -> bool:
    """Get feature flag with caching."""
    flag = FeatureFlag.query.filter_by(name=flag_name).first()
    return flag.enabled if flag else False

# Time-based cache invalidation
class TimedCache:
    def __init__(self, ttl_seconds: int = 300):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, key: str):
        if key in self.cache:
            value, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return value
            del self.cache[key]
        return None
    
    def set(self, key: str, value):
        self.cache[key] = (value, time.time())

</code></pre>
<h2>Debugging and Logging</h2>
<br>
<h3>Logging Configuration</h3>
<br>
<pre><code>

import logging
import sys
from datetime import datetime

def setup_logging(app):
    """Configure application logging."""
    
    # Create formatters
    detailed_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    simple_formatter = logging.Formatter(
        '%(levelname)s: %(message)s'
    )
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(simple_formatter)
    
    # File handler
    file_handler = logging.FileHandler(f'logs/app_{datetime.now().strftime("%Y%m%d")}.log')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(detailed_formatter)
    
    # Configure app logger
    app.logger.setLevel(logging.DEBUG)
    app.logger.addHandler(console_handler)
    app.logger.addHandler(file_handler)

</code></pre>
<h3>Debug Utilities</h3>
<br>
<pre><code>

import functools
import time

def debug_timing(func):
    """Decorator to measure function execution time."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        duration = time.time() - start_time
        
        if duration > 0.1:  # Log slow functions
            logging.warning(f"{func.__name__} took {duration:.3f}s")
        
        return result
    return wrapper

def debug_api_call(url: str, method: str = 'GET', **kwargs):
    """Debug utility for API calls."""
    logging.debug(f"API Call: {method} {url}")
    logging.debug(f"Parameters: {kwargs}")
    
    start_time = time.time()
    response = requests.request(method, url, **kwargs)
    duration = time.time() - start_time
    
    logging.debug(f"Response: {response.status_code} in {duration:.3f}s")
    return response

</code></pre>
<h2>Contributing Guidelines</h2>
<br>
<h3>Pull Request Process</h3>
<br>
<p>1. <strong>Branch Naming<strong>: Use descriptive branch names</p>
<br>
<pre><code>
   
   feature/add-chat-history
   bugfix/fix-oauth-redirect
   docs/update-api-reference

</code></pre>
<p>2. <strong>Commit Quality<strong>: Write clear, descriptive commits</p>
<br>
<p>3. <strong>Testing<strong>: Ensure all tests pass</p>
<br>
<p>4. <strong>Documentation<strong>: Update relevant documentation</p>
<br>
<p>5. <strong>Code Review<strong>: Address all review comments</p>
<br>
<h3>Code Review Checklist</h3>
<br>
<strong>Functionality:<strong>
<br>
<em> ✅ Code works as intended
<em> ✅ Handles edge cases appropriately
<em> ✅ Error handling is comprehensive
<em> ✅ Performance considerations addressed
<br>
<strong>Code Quality:<strong>
<br>
<em> ✅ Follows project coding standards
<em> ✅ Functions are appropriately sized
<em> ✅ Variable names are descriptive
<em> ✅ Comments explain complex logic
<br>
<strong>Testing:<strong>
<br>
<em> ✅ Unit tests cover new functionality
<em> ✅ Integration tests pass
<em> ✅ Edge cases are tested
<em> ✅ Test coverage maintained
<br>
<strong>Documentation:<strong>
<br>
<em> ✅ Function docstrings updated
<em> ✅ API documentation current
<em> ✅ README updated if needed
<em> ✅ Architecture docs updated
<br>
<h2>Development Tools</h2>
<br>
<h3>Recommended VS Code Extensions</h3>
<br>
<em> <strong>Python<strong>: Microsoft Python extension
<em> <strong>Pylance<strong>: Enhanced Python language server
<em> <strong>Black Formatter<strong>: Code formatting
<em> <strong>autoDocstring<strong>: Generate docstrings
<em> <strong>GitLens<strong>: Git integration
<em> <strong>Thunder Client<strong>: API testing
<br>
<h3>Useful Scripts</h3>
<br>
<p>Create helpful development scripts:</p>
<br>
<pre><code>

#!/bin/bash
# scripts/dev-setup.sh

echo "Setting up development environment..."

# Create virtual environment
python -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
pip install -r requirements_dev.txt

# Set up pre-commit hooks
pre-commit install

# Initialize database
python -c "from app import app, db; app.app_context().push(); db.create_all()"

echo "Development environment ready!"

<pre><code>

#!/bin/bash
# scripts/test-all.sh

echo "Running full test suite..."

# Code formatting
black --check .

# Linting
flake8 .

# Security scan
bandit -r .

# Type checking
mypy .

# Unit tests
pytest --cov=. --cov-report=html

echo "All tests completed!"

</code></pre>
<p>This development guide provides the foundation for maintaining code quality, consistency, and developer productivity on the NOUS Personal Assistant project.</p>
    </div>
</body>
</html>